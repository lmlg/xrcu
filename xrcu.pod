=encoding utf-8

=head1 NAME

XRCU is a library that provides efficient lock-less synchronization for read-mostly tasks and structures

=head1 ABOUT THIS DOCUMENT

This file is meant to document the XRCU library, including internal details
and the rationale behind the decisions taken.

This document assumes that the reader is at least somewhat familiar with such
concepts as multi-threading, lock-free algorithms and data structures, and
read-copy-update (RCU).

=head1 ABOUT LOCK FREE ALGORITHMS AND STRUCTURES

The term I<lock free> is used to refer to several different things depending
on the author, but the basic idea is that an algorithm or structure is lock
free if multiple threads can operate on it without the end result being
dependent on said threads' scheduling. That is, it doesn't matter if the
involved threads are suspended or preempted; progress is guaranteed.

The usually mentioned advantage of lock freedom is performance. When you are
using lock free algorithms, you naturally avoid using things like mutexes,
which can have a non-negligible performance impact. On the other hand, other
people point out that lock free algorithms are typically harder to understand,
that debugging is notoriously difficult, and that the benefits generally do
not compensate for these complexities.

The reason why this library was developed is to give other programmers another
option when designing high performant, low latency systems. I do not claim that
lock freedom is a silver bullet when it comes to making programs faster. On the
other hand, it's also hard to argue that lock contention tends to be a real
bottleneck, and several projects have moved towards lock free structures given
the performance benefits they bring (see for example, many kernels).

=head1 ABOUT RCU

There is a big problem with using lock free algorithms in programming languages
that feature manual memory management, and it has to do with reclamation. Since
lock freedom implies that multiple threads may operate on a given structure
concurrently, it is possible to find ourselves in a situation in which a thread
is reading some data, while another one is modifying or deleting that same
piece of data, potentially freeing the memory associated to it.

As such, lock freedom isn't feasible as in languages like C and C++. We need
an additional subsystem that allows us to synchronize reclamation without using
heavyweight methods like mutexes (we are developing a lock-free library, after
all).

This is where RCU comes in. RCU, short for read-copy-update, is a mechanism
that allows multiple threads to I<read> from memory, while postponing
reclamations until it is safe to do so (i.e: until no readers are operating
on said memory).

There are several different ways to implement RCU, and the one chosen in this
library will be detailed later. For now, it's important to notice that RCU
typically makes reading from shared memory a very cheap operation, while
imposing more overhead on updates. Thus, it's more suited for tasks in which
reads are more frequent than modifications.

It should be noted that RCU is not the only way to manage memory reclamations
in a multi-threaded environment, but as its name implies, XRCU chose it because
it was deemed the best option. Since lock-free structures rely on RCU to work
properly, we'll describe the RCU interface that this library exposes first.

=head2 RCU critical section management

RCU is based on the concept of I<critical sections>, code fragments that
execute under the guarantee that no reclamation can take place. This allows
the user to safely read from shared memory, knowing that it will be valid
during the critical section. Writes have to be synchronized independently
of RCU, however.

It should be noted that RCU critical sections don't prevent I<all> memory
reclamation, they only affect destruction of objects that are derived from
a type defined in XRCU, called C<finalizable>. If you wish to use the RCU
API, all you need to do is make your types derive from C<finalizable> and
you'll be set. Any other memory management function, like C<malloc> and friends
is unaffected by RCU as implemented in this library.

Critical sections are managed through the following API:

=over 4

=item void enter_cs (void);

Starts a critical section for the calling thread. Critical sections can be
safely nested without problem. As long as we are in a critical section,
C<finalizable> objects cannot be reclaimed.

=item void exit_cs (void);

Ends a critical section. This is generally called after the calling thread
is done reading from shared memory, and wants to signal that reclamations
should be re-allowed. The effects of calling C<exit_cs> when the calling thread
is not in a critical section are undefined.

=item bool in_cs (void);

Returns true if the calling thread is in a critical section; false otherwise.

=item bool sync (void);

Waits until all threads are outside a critical section, and returns true
afterwards. If a deadlock is detected (because the calling thread is in a
critical section, for example), this function returns false immediately
without waiting.

Note that this call is affected by I<ongoing> critical sections. If a thread
enters a new one after another thread has already called C<sync>, the blocked
thread will not wait for it.

=item struct cs_guard

This type is defined such that its constructor calls C<enter_cs>, and its
destructor calls C<exit_cs>; it has no internal state. As its name implies,
it's useful as a guard to manage entering and exiting a critical section in
a way that is exception safe. A few types in this library are derived from
C<cs_guard>, such as iterators, since they need to examine potentially many
elements from a container without their memory being reclaimed.

=back

=head2 RCU finalizable objects

As it was mentioned before, XRCU defines a type called C<finalizable> that
is specifically designed to make its destruction safe (i.e: Only once all
threads are outside a critical section). This type defines the following
interface:

  struct finalizable
    {
      virtual void safe_destroy () {}
      virtual ~finalizable () {}
    };

Under most circumstances, it's enough for a user-defined type to derive from
C<finalizable> and leave it at that. However, the above 2 methods are provided
as virtual for customization's sake. When a C<finalizable> object is reclaimed
by the RCU subsystem, it will call the C<safe_destroy> method. The default
implementation simply calls the object's destructor and frees the memory
associated to it. If, for whatever reason, a user wants to override this
behaviour, they may do so by extending either of those methods.

In addition, the following API is available when dealing with finalizables:

=over 4

=item void finalize (finalizable *F);

Adds the object F to the calling thread's list of pending finalizable objects.
Each thread has a limit of C<finalizables>, and keeps count on them. Once they
reach C<XRCU_MAX_FINS>, they are scheduled for reclamation, and will be
collected once it's safe to do so.

Only a single call to C<finalize> is allowed on a particular object. If this
function is called more than once on the same object (Either by the same
thread, or another), the behaviour is undefined.

=item bool flush_finalizers (void);

Schedule all the calling thread's accumulated C<finalizable> objects for
reclamation immediately. Returns true if successful, false if a deadlock was
detected. Note that this call may block until all threads are outside a
critical section (Much as a call to C<sync> would).

=back


